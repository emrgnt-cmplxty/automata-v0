{"task_id": "LeetCode-Hard/0", "completion": "\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    banned = set(banned)\n    ans = []\n    for i in range(n):\n        if i in banned:\n            ans.append(-1)\n        elif i == p or (max(abs(p - i), abs(p - (i + k - 1))) % 2 == 0 and k % 2 == 1):\n            ans.append(abs(p - i)// k)\n        else:\n            ans.append(-1)\n    return ans\n", "raw_completion": "```python\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    banned = set(banned)\n    ans = []\n    for i in range(n):\n        if i in banned:\n            ans.append(-1)\n        elif i == p or (max(abs(p - i), abs(p - (i + k - 1))) % 2 == 0 and k % 2 == 1):\n            ans.append(abs(p - i)// k)\n        else:\n            ans.append(-1)\n    return ans\n```"}
{"task_id": "LeetCode-Hard/29", "completion": "\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    primes = ['2', '3', '5', '7']\n    for i in range(1,n+1):\n        for count in range(1, min(i,k)+1):\n            for length in range(minLength, i-count*minLength+2):\n                if s[i-length] in primes and s[i-1] not in primes:\n                    dp[i][count] = (dp[i][count] + dp[i-length][count-1]) % mod\n    return dp[-1][-1]\n", "raw_completion": "```python\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    primes = ['2', '3', '5', '7']\n    for i in range(1,n+1):\n        for count in range(1, min(i,k)+1):\n            for length in range(minLength, i-count*minLength+2):\n                if s[i-length] in primes and s[i-1] not in primes:\n                    dp[i][count] = (dp[i][count] + dp[i-length][count-1]) % mod\n    return dp[-1][-1]\n```"}
{"task_id": "LeetCode-Hard/12", "completion": "\ndef rootCount(edges, guesses, k):\n    n = len(edges) + 1\n    inDeg, outDeg, cnt = [0] * n, [0] * n, [0] * n\n    for u, v in edges:\n        outDeg[u] += 1\n        inDeg[v] += 1\n    for u, v in guesses:\n        cnt[u] += 1\n    res = 0\n    for i in range(n):\n        if max(outDeg[i] - (cnt[i] if inDeg[i] == 0 else 0), 0) + max(inDeg[i] - (n - 1 - cnt[i] if outDeg[i] == 0 else 0), 0) >= k:\n            res += 1\n    return res\n", "raw_completion": "```python\ndef rootCount(edges, guesses, k):\n    n = len(edges) + 1\n    inDeg, outDeg, cnt = [0] * n, [0] * n, [0] * n\n    for u, v in edges:\n        outDeg[u] += 1\n        inDeg[v] += 1\n    for u, v in guesses:\n        cnt[u] += 1\n    res = 0\n    for i in range(n):\n        if max(outDeg[i] - (cnt[i] if inDeg[i] == 0 else 0), 0) + max(inDeg[i] - (n - 1 - cnt[i] if outDeg[i] == 0 else 0), 0) >= k:\n            res += 1\n    return res\n```"}
{"task_id": "LeetCode-Hard/20", "completion": "\ndef countAnagrams(s: str) -> int:\n    from math import factorial\n    words = s.split()\n    result = 1\n    for word in words:\n        freq = [word.count(c) for c in set(word)]\n        result *= factorial(len(word)) \n        for f in freq:\n            result /= factorial(f)\n        result = result % (10**9 + 7)\n    return int(result)\n", "raw_completion": "```python\ndef countAnagrams(s: str) -> int:\n    from math import factorial\n    words = s.split()\n    result = 1\n    for word in words:\n        freq = [word.count(c) for c in set(word)]\n        result *= factorial(len(word)) \n        for f in freq:\n            result /= factorial(f)\n        result = result % (10**9 + 7)\n    return int(result)\n```"}
{"task_id": "LeetCode-Hard/36", "completion": "\ndef minCost(nums, cost):\n    middle = sorted(zip(nums, cost), key=lambda x: x[0])[len(nums) // 2][0]\n    return sum(abs(num - middle) * c for num, c in zip(nums, cost))\n", "raw_completion": "```python\ndef minCost(nums, cost):\n    middle = sorted(zip(nums, cost), key=lambda x: x[0])[len(nums) // 2][0]\n    return sum(abs(num - middle) * c for num, c in zip(nums, cost))\n```"}
{"task_id": "LeetCode-Hard/15", "completion": "\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    max_time = 0\n    workers = sorted(range(k), key=lambda x: (time[x][0] + time[x][2], x))\n    boxes_moved = [0] * k\n    right = []\n\n    for i in range(n):\n        if not right and i < k:\n            worker = workers[i]\n        else:\n            worker = heapq.heappop(right)[1]\n        arrival = max_time + time[worker][2] if right else max_time + time[worker][0]\n        max_time = max(max_time, arrival)\n        boxes_moved[worker] += 1\n        heapq.heappush(right, (arrival + time[worker][3], worker))\n\n    return max_time\n", "raw_completion": "```python\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    max_time = 0\n    workers = sorted(range(k), key=lambda x: (time[x][0] + time[x][2], x))\n    boxes_moved = [0] * k\n    right = []\n\n    for i in range(n):\n        if not right and i < k:\n            worker = workers[i]\n        else:\n            worker = heapq.heappop(right)[1]\n        arrival = max_time + time[worker][2] if right else max_time + time[worker][0]\n        max_time = max(max_time, arrival)\n        boxes_moved[worker] += 1\n        heapq.heappush(right, (arrival + time[worker][3], worker))\n\n    return max_time\n```"}
{"task_id": "LeetCode-Hard/27", "completion": "\ndef countPalindromes(s: str) -> int:\n    MOD = 10**9 + 7\n    counts = [0]*10\n    dp = [[0]*10 for _ in range(10)]\n    tot = [0]*10\n    res = 0\n    for i in reversed(s):\n        i = int(i)\n        for j in range(10):\n            if i==j:\n                res = (res+tot[j]) % MOD\n            else:\n                res = (res+dp[j][i]) % MOD\n        new_dp = [x for x in dp[i]]\n        for j in range(10):\n            new_dp[j] = (new_dp[j]+counts[j]) % MOD\n        counts[i] += 1\n        dp[i] = new_dp\n        tot[i] = (tot[i]+new_dp[i]) % MOD\n    return res\n", "raw_completion": "```python\ndef countPalindromes(s: str) -> int:\n    MOD = 10**9 + 7\n    counts = [0]*10\n    dp = [[0]*10 for _ in range(10)]\n    tot = [0]*10\n    res = 0\n    for i in reversed(s):\n        i = int(i)\n        for j in range(10):\n            if i==j:\n                res = (res+tot[j]) % MOD\n            else:\n                res = (res+dp[j][i]) % MOD\n        new_dp = [x for x in dp[i]]\n        for j in range(10):\n            new_dp[j] = (new_dp[j]+counts[j]) % MOD\n        counts[i] += 1\n        dp[i] = new_dp\n        tot[i] = (tot[i]+new_dp[i]) % MOD\n    return res\n```"}
{"task_id": "LeetCode-Hard/11", "completion": "\ndef findMinimumTime(tasks: list[list[int]]) -> int:\n    # Sorting the tasks by end time and then start time in descending order\n    tasks.sort(key=lambda x: (-x[1], -x[0]))\n    time, res = 0, 0\n    for start, end, duration in tasks:\n        if end < time:\n            res += min(duration, time - start)\n            time = max(start, time - duration)\n        else:\n            res += min(duration, end - time)\n            time += min(duration, end - time)\n    return res\n", "raw_completion": "```python\ndef findMinimumTime(tasks: list[list[int]]) -> int:\n    # Sorting the tasks by end time and then start time in descending order\n    tasks.sort(key=lambda x: (-x[1], -x[0]))\n    time, res = 0, 0\n    for start, end, duration in tasks:\n        if end < time:\n            res += min(duration, time - start)\n            time = max(start, time - duration)\n        else:\n            res += min(duration, end - time)\n            time += min(duration, end - time)\n    return res\n```"}
{"task_id": "LeetCode-Hard/1", "completion": "\nfrom collections import defaultdict\ndef collectTheCoins(coins, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    total, dist = 0, [-1] * len(coins)\n    vertices = [a for a in range(len(coins)) if coins[a]]\n    for v in vertices:\n        stack, dist[v] = [v], 0\n        while stack:\n            x = stack.pop()\n            if 0 <= dist[x] < dist[v]:\n                stack = [x]\n            elif dist[x] == dist[v] != 0:\n                stack.append(x)\n            else:\n                for y in graph[x]:\n                    if dist[v] < 2 or dist[y] < 0:\n                        dist[y] = dist[x] + 1\n                        stack.append(y)\n        total += 2 * (dist[v] - 1)\n    return total - max(dist) + len(vertices)\n", "raw_completion": "```python\nfrom collections import defaultdict\ndef collectTheCoins(coins, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    total, dist = 0, [-1] * len(coins)\n    vertices = [a for a in range(len(coins)) if coins[a]]\n    for v in vertices:\n        stack, dist[v] = [v], 0\n        while stack:\n            x = stack.pop()\n            if 0 <= dist[x] < dist[v]:\n                stack = [x]\n            elif dist[x] == dist[v] != 0:\n                stack.append(x)\n            else:\n                for y in graph[x]:\n                    if dist[v] < 2 or dist[y] < 0:\n                        dist[y] = dist[x] + 1\n                        stack.append(y)\n        total += 2 * (dist[v] - 1)\n    return total - max(dist) + len(vertices)\n```"}
{"task_id": "LeetCode-Hard/21", "completion": "\ndef countPartitions(nums: [int], k: int) -> int:\n    MOD = 10**9 + 7\n    total_sum = sum(nums)\n    prefix_sum = [0]*(len(nums)+1)\n    for i in range(1, len(nums)+1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n\n    num_partitions = [0]*(total_sum+1)\n    num_partitions[0] = 1\n    for i in range(1, len(nums)+1):\n        for sum_val in range(total_sum, prefix_sum[i]-1, -1):\n            num_partitions[sum_val] = (num_partitions[sum_val] + num_partitions[sum_val - nums[i-1]]) % MOD\n\n    great_partitions = 0\n    for sum_val in range(k, total_sum + 1):\n        if sum_val >= total_sum - k + 1:\n            break\n        great_partitions = (great_partitions + num_partitions[sum_val]) % MOD\n\n    return great_partitions\n", "raw_completion": "```python\ndef countPartitions(nums: [int], k: int) -> int:\n    MOD = 10**9 + 7\n    total_sum = sum(nums)\n    prefix_sum = [0]*(len(nums)+1)\n    for i in range(1, len(nums)+1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n\n    num_partitions = [0]*(total_sum+1)\n    num_partitions[0] = 1\n    for i in range(1, len(nums)+1):\n        for sum_val in range(total_sum, prefix_sum[i]-1, -1):\n            num_partitions[sum_val] = (num_partitions[sum_val] + num_partitions[sum_val - nums[i-1]]) % MOD\n\n    great_partitions = 0\n    for sum_val in range(k, total_sum + 1):\n        if sum_val >= total_sum - k + 1:\n            break\n        great_partitions = (great_partitions + num_partitions[sum_val]) % MOD\n\n    return great_partitions\n```"}
{"task_id": "LeetCode-Hard/7", "completion": "\ndef minCost(basket1: list[int], basket2: list[int]) -> int:\n  basket1.sort()\n  basket2.sort()\n  if basket1 == basket2:\n    return 0\n  else:\n    totalCost = 0\n    for i in range(len(basket1)):\n      index = basket2.index(basket1[i]) if basket1[i] in basket2 else -1\n      if index != -1:\n          totalCost += min(basket1[i], basket2[index]) \n          basket2.pop(index)\n      else:\n          return -1\n    return totalCost\n", "raw_completion": "```python\ndef minCost(basket1: list[int], basket2: list[int]) -> int:\n  basket1.sort()\n  basket2.sort()\n  if basket1 == basket2:\n    return 0\n  else:\n    totalCost = 0\n    for i in range(len(basket1)):\n      index = basket2.index(basket1[i]) if basket1[i] in basket2 else -1\n      if index != -1:\n          totalCost += min(basket1[i], basket2[index]) \n          basket2.pop(index)\n      else:\n          return -1\n    return totalCost\n```"}
{"task_id": "LeetCode-Hard/10", "completion": "\ndef findShortestCycle(n: int, edges) -> int: \n    adj_list = [[] for _ in range(n)]\n    for u, v in edges: \n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    shortest_cycle = n + 1  \n\n    for i in range(n): \n        visited = [-1]*n \n        visited[i] = 0\n        queue = [i]\n        while queue: \n            node = queue.pop(0) \n            for neighbor in adj_list[node]: \n                if visited[neighbor] == -1: \n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor) \n                elif visited[neighbor] >= visited[node]: \n                    shortest_cycle = min(shortest_cycle, visited[node] + visited[neighbor] + 1) \n\n    if shortest_cycle == n + 1: \n        return -1\n    else: \n        return shortest_cycle\n", "raw_completion": "```python\ndef findShortestCycle(n: int, edges) -> int: \n    adj_list = [[] for _ in range(n)]\n    for u, v in edges: \n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    shortest_cycle = n + 1  \n\n    for i in range(n): \n        visited = [-1]*n \n        visited[i] = 0\n        queue = [i]\n        while queue: \n            node = queue.pop(0) \n            for neighbor in adj_list[node]: \n                if visited[neighbor] == -1: \n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor) \n                elif visited[neighbor] >= visited[node]: \n                    shortest_cycle = min(shortest_cycle, visited[node] + visited[neighbor] + 1) \n\n    if shortest_cycle == n + 1: \n        return -1\n    else: \n        return shortest_cycle\n```"}
{"task_id": "LeetCode-Hard/13", "completion": "\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    MOD = 10**9 + 7\n    pref = [0]*(len(types)+1)\n    for i in range(len(types)-1, -1, -1):\n        pref[i] = pref[i+1] + types[i][0]\n    dp = [[0]*(pref[0]+1) for _ in range(len(types)+1)]\n    dp[0][0] = 1\n    for i in range(1, len(types)+1):\n        a, b = types[i-1]\n        dp[i] = dp[i-1][:]\n        for j in range(1, pref[i-1]+1):\n            if j > a*b:\n                dp[i][j] = (dp[i][j] + dp[i][j-1] - dp[i-1][j-a*b-1] + dp[i-1][j-a*b]) % MOD\n            else:\n                dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n    return dp[-1][target]\n", "raw_completion": "```python\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    MOD = 10**9 + 7\n    pref = [0]*(len(types)+1)\n    for i in range(len(types)-1, -1, -1):\n        pref[i] = pref[i+1] + types[i][0]\n    dp = [[0]*(pref[0]+1) for _ in range(len(types)+1)]\n    dp[0][0] = 1\n    for i in range(1, len(types)+1):\n        a, b = types[i-1]\n        dp[i] = dp[i-1][:]\n        for j in range(1, pref[i-1]+1):\n            if j > a*b:\n                dp[i][j] = (dp[i][j] + dp[i][j-1] - dp[i-1][j-a*b-1] + dp[i-1][j-a*b]) % MOD\n            else:\n                dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD\n    return dp[-1][target]\n```"}
{"task_id": "LeetCode-Hard/14", "completion": "\nfrom typing import List\nfrom math import gcd\nfrom functools import reduce\n\ndef findValidSplit(nums: List[int]) -> int:\n    total_product = reduce(lambda a, b: a * b, nums)\n    current_product = 1\n  \n    for i in range(len(nums) - 1):\n        current_product *= nums[i]\n        other_product = total_product // current_product\n        \n        if gcd(current_product, other_product) == 1:\n            return i\n    return -1\n", "raw_completion": "```python\nfrom typing import List\nfrom math import gcd\nfrom functools import reduce\n\ndef findValidSplit(nums: List[int]) -> int:\n    total_product = reduce(lambda a, b: a * b, nums)\n    current_product = 1\n  \n    for i in range(len(nums) - 1):\n        current_product *= nums[i]\n        other_product = total_product // current_product\n        \n        if gcd(current_product, other_product) == 1:\n            return i\n    return -1\n```"}
{"task_id": "LeetCode-Hard/38", "completion": "\nfrom typing import List\n\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for j in range(i, len(nums)):\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            if min_val == minK and max_val == maxK:\n                count += 1\n            elif min_val > minK or max_val > maxK:\n                break\n    return count\n", "raw_completion": "```python\nfrom typing import List\n\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for j in range(i, len(nums)):\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            if min_val == minK and max_val == maxK:\n                count += 1\n            elif min_val > minK or max_val > maxK:\n                break\n    return count\n```"}
{"task_id": "LeetCode-Hard/23", "completion": "\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    degrees = [0] * (n + 1)\n\n    for edge in edges:\n        degrees[edge[0]] += 1\n        degrees[edge[1]] += 1\n\n    odd_nodes = 0\n    for node in range(1, n + 1):\n        if degrees[node] % 2 != 0:\n            odd_nodes += 1\n\n    return odd_nodes <= 2\n", "raw_completion": "```python\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    degrees = [0] * (n + 1)\n\n    for edge in edges:\n        degrees[edge[0]] += 1\n        degrees[edge[1]] += 1\n\n    odd_nodes = 0\n    for node in range(1, n + 1):\n        if degrees[node] % 2 != 0:\n            odd_nodes += 1\n\n    return odd_nodes <= 2\n```"}
{"task_id": "LeetCode-Hard/34", "completion": "\n# Definition for binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef treeQueries(root: Optional[TreeNode], queries: List[int]) -> List[int]:\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        height_map[node.val] = 1 + max(left, right)\n        return height_map[node.val]\n\n    def removeSubtree(node: TreeNode, query: int) -> int:\n        if not node:\n            return 0\n        if node.val == query:\n            return 0\n        left = removeSubtree(node.left, query)\n        right = removeSubtree(node.right, query)\n        return 1 + max(left, right)\n\n    height_map = collections.defaultdict(int)\n    dfs(root)\n    result = []\n    for query in queries:\n        result.append(removeSubtree(root, query))\n    return result\n", "raw_completion": "```python\n# Definition for binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef treeQueries(root: Optional[TreeNode], queries: List[int]) -> List[int]:\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        height_map[node.val] = 1 + max(left, right)\n        return height_map[node.val]\n\n    def removeSubtree(node: TreeNode, query: int) -> int:\n        if not node:\n            return 0\n        if node.val == query:\n            return 0\n        left = removeSubtree(node.left, query)\n        right = removeSubtree(node.right, query)\n        return 1 + max(left, right)\n\n    height_map = collections.defaultdict(int)\n    dfs(root)\n    result = []\n    for query in queries:\n        result.append(removeSubtree(root, query))\n    return result\n```"}
{"task_id": "LeetCode-Hard/40", "completion": "\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    dp[0][grid[0][0] % k] = 1\n    mod = 10**9 + 7\n    for i in range(m):\n        dpNew = [[0 for _ in range(k)] for _ in range(n)]\n        for j in range(n):\n            for t in range(k):\n                if j > 0:\n                    dpNew[j][(t+grid[i][j])%k] += dp[j-1][t] % mod\n                if i > 0:\n                    dpNew[j][(t+grid[i][j])%k] += dp[j][t] % mod\n        dp = dpNew\n    return dp[-1][0] % mod\n", "raw_completion": "```python\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    dp[0][grid[0][0] % k] = 1\n    mod = 10**9 + 7\n    for i in range(m):\n        dpNew = [[0 for _ in range(k)] for _ in range(n)]\n        for j in range(n):\n            for t in range(k):\n                if j > 0:\n                    dpNew[j][(t+grid[i][j])%k] += dp[j-1][t] % mod\n                if i > 0:\n                    dpNew[j][(t+grid[i][j])%k] += dp[j][t] % mod\n        dp = dpNew\n    return dp[-1][0] % mod\n```"}
{"task_id": "LeetCode-Hard/35", "completion": "\ndef makeSimilar(nums: list[int], target: list[int]) -> int:\n    diff_sum = sum((n - m) for n, m in zip(nums, target))\n    if diff_sum:\n        return -1\n    else:\n        return sum(abs(n - m) for n, m in zip(nums, target)) // 4\n", "raw_completion": "```python\ndef makeSimilar(nums: list[int], target: list[int]) -> int:\n    diff_sum = sum((n - m) for n, m in zip(nums, target))\n    if diff_sum:\n        return -1\n    else:\n        return sum(abs(n - m) for n, m in zip(nums, target)) // 4\n```"}
{"task_id": "LeetCode-Hard/17", "completion": "\ndef minCost(nums: List[int], k: int) -> int:\n    dp, sums, freq = [[float(\"inf\")] * len(nums) for _ in range(len(nums))], [0] * len(nums), {}\n    \n    for i, num in enumerate(nums):\n        if i > 0:\n            sums[i] = sums[i - 1]\n        if num not in freq:\n            freq[num] = 0\n        freq[num] += 1\n        if freq[num] == 2:\n            sums[i] += 2\n        elif freq[num] > 2:\n            sums[i] += 1\n            \n        dp[i][i] = k\n    \n    for size in range(1, len(nums)):\n        for i in range(len(nums) - size):\n            j = i + size\n            dp[i][j] = min(dp[i][j], dp[i][j - 1] + sums[j] - (sums[i] - 1 if i > 0 else 0) + k)\n            dp[i][j] = min(dp[i][j], dp[i + 1][j] + sums[j - 1] - (sums[i] if i > 0 else 0) + k)\n    return dp[0][-1]\n", "raw_completion": "```python\ndef minCost(nums: List[int], k: int) -> int:\n    dp, sums, freq = [[float(\"inf\")] * len(nums) for _ in range(len(nums))], [0] * len(nums), {}\n    \n    for i, num in enumerate(nums):\n        if i > 0:\n            sums[i] = sums[i - 1]\n        if num not in freq:\n            freq[num] = 0\n        freq[num] += 1\n        if freq[num] == 2:\n            sums[i] += 2\n        elif freq[num] > 2:\n            sums[i] += 1\n            \n        dp[i][i] = k\n    \n    for size in range(1, len(nums)):\n        for i in range(len(nums) - size):\n            j = i + size\n            dp[i][j] = min(dp[i][j], dp[i][j - 1] + sums[j] - (sums[i] - 1 if i > 0 else 0) + k)\n            dp[i][j] = min(dp[i][j], dp[i + 1][j] + sums[j - 1] - (sums[i] if i > 0 else 0) + k)\n    return dp[0][-1]\n```"}
{"task_id": "LeetCode-Hard/8", "completion": "\ndef countQuadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if nums[i] < nums[j] < nums[k] < nums[l]:\n                        count += 1\n    return count\n", "raw_completion": "```python\ndef countQuadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if nums[i] < nums[j] < nums[k] < nums[l]:\n                        count += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/33", "completion": "\ndef secondGreaterElement(nums: list) -> list:\n    result = [-1]*len(nums)\n    stack = []\n    for i in reversed(range(len(nums))):\n        while stack and nums[stack[-1]]<=nums[i]:\n            stack.pop()\n        if len(stack)>=2:\n            result[i] = nums[stack[-2]]\n        stack.append(i)\n    return result\n", "raw_completion": "```python\ndef secondGreaterElement(nums: list) -> list:\n    result = [-1]*len(nums)\n    stack = []\n    for i in reversed(range(len(nums))):\n        while stack and nums[stack[-1]]<=nums[i]:\n            stack.pop()\n        if len(stack)>=2:\n            result[i] = nums[stack[-2]]\n        stack.append(i)\n    return result\n```"}
{"task_id": "LeetCode-Hard/3", "completion": "\ndef findTheString(lcp):\n    n, word = len(lcp), [0]*len(lcp)\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if lcp[i][j] <= lcp[i+1][j]:\n                val = min(word[j], word[i]+1)\n                word[i]=val\n            else:\n                x = min(word[i+1], word[j] - lcp[i+1][j])\n                if x >= 26: return \"\"\n                word[i] = x\n    return \"\".join(chr(i+97) for i in word)\n", "raw_completion": "```python\ndef findTheString(lcp):\n    n, word = len(lcp), [0]*len(lcp)\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if lcp[i][j] <= lcp[i+1][j]:\n                val = min(word[j], word[i]+1)\n                word[i]=val\n            else:\n                x = min(word[i+1], word[j] - lcp[i+1][j])\n                if x >= 26: return \"\"\n                word[i] = x\n    return \"\".join(chr(i+97) for i in word)\n```"}
{"task_id": "LeetCode-Hard/39", "completion": "\ndef lengthOfLIS(nums, k):\n    tails, res = [0] * len(nums), 0\n    for num in nums:\n        i, j = 0, res\n        while i < j:\n            m = (i + j) // 2\n            if tails[m] < num and (num - tails[m]) <= k: i = m + 1\n            else: j = m\n        tails[i] = num\n        if i == res: res += 1\n    return res\n", "raw_completion": "```python\ndef lengthOfLIS(nums, k):\n    tails, res = [0] * len(nums), 0\n    for num in nums:\n        i, j = 0, res\n        while i < j:\n            m = (i + j) // 2\n            if tails[m] < num and (num - tails[m]) <= k: i = m + 1\n            else: j = m\n        tails[i] = num\n        if i == res: res += 1\n    return res\n```"}
{"task_id": "LeetCode-Hard/9", "completion": "\ndef putMarbles(weights: list[int], K: int) -> int:\n    n = len(weights)\n    memo = {}\n    \n    def dp(l, k):\n        nonlocal weights,n\n        if l == n:\n            return 0 if k == 0 else float('inf')\n        if k == 0:\n            return float('inf') if l != n else 0\n        if (l,k) in memo:\n            return memo[l,k]\n        best = float('inf')          \n        for r in range(l,n):\n            sum_ = sum(weights[l:r+1]) \n            best = min(best, max( sum_ + weights[l] + weights[r], dp(r+1,k-1)))\n        memo[(l,k)] = best\n        return best\n    \n    max_score = dp(0,K)\n    min_score = dp(0,1) - max(weights)*2\n    \n    return max_score - min_score\n", "raw_completion": "```python\ndef putMarbles(weights: list[int], K: int) -> int:\n    n = len(weights)\n    memo = {}\n    \n    def dp(l, k):\n        nonlocal weights,n\n        if l == n:\n            return 0 if k == 0 else float('inf')\n        if k == 0:\n            return float('inf') if l != n else 0\n        if (l,k) in memo:\n            return memo[l,k]\n        best = float('inf')          \n        for r in range(l,n):\n            sum_ = sum(weights[l:r+1]) \n            best = min(best, max( sum_ + weights[l] + weights[r], dp(r+1,k-1)))\n        memo[(l,k)] = best\n        return best\n    \n    max_score = dp(0,K)\n    min_score = dp(0,1) - max(weights)*2\n    \n    return max_score - min_score\n```"}
{"task_id": "LeetCode-Hard/4", "completion": "\ndef handleQuery(nums1: list[int], nums2: list[int], queries: list[list[int]]) -> list[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] = nums2[i] + nums1[i] * query[1]\n        elif query[0] == 3:\n            results.append(sum(nums2))\n    return results\n", "raw_completion": "```python\ndef handleQuery(nums1: list[int], nums2: list[int], queries: list[list[int]]) -> list[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] = nums2[i] + nums1[i] * query[1]\n        elif query[0] == 3:\n            results.append(sum(nums2))\n    return results\n```"}
{"task_id": "LeetCode-Hard/37", "completion": "\ndef componentValue(nums, edges):\n    totalSum = sum(nums)\n    eachVal = totalSum // len(nums)\n    if totalSum % len(nums) != 0:\n        return -1\n    g = [[] for _ in range(len(nums))]\n    total = [0] * len(nums)\n    for u, v in edges:\n        g[u].append((v, len(g[v])))\n        g[v].append((u, len(g[u]) - 1))\n    def dfs(v, p):\n        total[v] = nums[v]\n        res = 0\n        for u, ep in g[v]:\n            if u == p:\n                continue\n            t = dfs(u, v)\n            if total[u] == eachVal:\n                total[u] = 0\n                res += 1\n            total[v] += total[u]\n            res += t\n        return res\n    dfs(0, -1)\n    if total[0] != eachVal:\n        return -1\n    return dfs(0, -1)\n", "raw_completion": "```python\ndef componentValue(nums, edges):\n    totalSum = sum(nums)\n    eachVal = totalSum // len(nums)\n    if totalSum % len(nums) != 0:\n        return -1\n    g = [[] for _ in range(len(nums))]\n    total = [0] * len(nums)\n    for u, v in edges:\n        g[u].append((v, len(g[v])))\n        g[v].append((u, len(g[u]) - 1))\n    def dfs(v, p):\n        total[v] = nums[v]\n        res = 0\n        for u, ep in g[v]:\n            if u == p:\n                continue\n            t = dfs(u, v)\n            if total[u] == eachVal:\n                total[u] = 0\n                res += 1\n            total[v] += total[u]\n            res += t\n        return res\n    dfs(0, -1)\n    if total[0] != eachVal:\n        return -1\n    return dfs(0, -1)\n```"}
{"task_id": "LeetCode-Hard/6", "completion": "\ndef minimumVisitedCells(grid):\n    n, m = len(grid[0]), len(grid)\n    dp = [[1<<30]*n for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            for k in range(1, grid[i][j]+1):\n                if j+k < n:\n                    dp[i][j+k] = min(dp[i][j+k], dp[i][j]+1)\n                if i+k < m:\n                    dp[i+k][j] = min(dp[i+k][j], dp[i][j]+1)\n    return dp[-1][-1] if dp[-1][-1] != 1<<30 else -1\n", "raw_completion": "```python\ndef minimumVisitedCells(grid):\n    n, m = len(grid[0]), len(grid)\n    dp = [[1<<30]*n for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            for k in range(1, grid[i][j]+1):\n                if j+k < n:\n                    dp[i][j+k] = min(dp[i][j+k], dp[i][j]+1)\n                if i+k < m:\n                    dp[i+k][j] = min(dp[i+k][j], dp[i][j]+1)\n    return dp[-1][-1] if dp[-1][-1] != 1<<30 else -1\n```"}
{"task_id": "LeetCode-Hard/28", "completion": "\ndef countSubarrays(nums, k):\n    n = len(nums)\n    s = [0] * (n+1)\n    for i in range(n):\n        if nums[i] < k:\n            s[i+1] = s[i] - 1\n        elif nums[i] > k:\n            s[i+1] = s[i] + 1\n        else:\n            s[i+1] = s[i]\n            ki = i+1\n    s.sort()\n    ans = 0\n    pre = 0\n    cnt = 0\n    for i in range(n+1):\n        if s[i] != pre:\n            ans += cnt * (cnt-1) // 2\n            cnt = 1\n            pre = s[i]\n        else:\n            cnt += 1\n    ans += cnt * (cnt-1) // 2\n    return ans - (n-ki+1)*ki//2\n", "raw_completion": "```python\ndef countSubarrays(nums, k):\n    n = len(nums)\n    s = [0] * (n+1)\n    for i in range(n):\n        if nums[i] < k:\n            s[i+1] = s[i] - 1\n        elif nums[i] > k:\n            s[i+1] = s[i] + 1\n        else:\n            s[i+1] = s[i]\n            ki = i+1\n    s.sort()\n    ans = 0\n    pre = 0\n    cnt = 0\n    for i in range(n+1):\n        if s[i] != pre:\n            ans += cnt * (cnt-1) // 2\n            cnt = 1\n            pre = s[i]\n        else:\n            cnt += 1\n    ans += cnt * (cnt-1) // 2\n    return ans - (n-ki+1)*ki//2\n```"}
{"task_id": "LeetCode-Hard/18", "completion": "\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    graph = [[] for _ in range(n)]\n    for u,v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    subSum = [0]*n\n    total = [0]*n\n\n    def dfs1(u=0, p=-1):\n        subSum[u] = price[u]\n        for v in graph[u]:\n            if v == p:\n                continue\n            dfs1(v,u)\n            subSum[u] += subSum[v]\n\n    def dfs2(u=0, p=-1):\n        total[u] = subSum[u] + (total[p]-subSum[u] if p!=-1 else 0)\n        for v in graph[u]:\n            if v == p:\n                continue\n            dfs2(v,u)\n\n    dfs1()\n    dfs2()\n    return max(total) - min(subSum)\n", "raw_completion": "```python\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    graph = [[] for _ in range(n)]\n    for u,v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    subSum = [0]*n\n    total = [0]*n\n\n    def dfs1(u=0, p=-1):\n        subSum[u] = price[u]\n        for v in graph[u]:\n            if v == p:\n                continue\n            dfs1(v,u)\n            subSum[u] += subSum[v]\n\n    def dfs2(u=0, p=-1):\n        total[u] = subSum[u] + (total[p]-subSum[u] if p!=-1 else 0)\n        for v in graph[u]:\n            if v == p:\n                continue\n            dfs2(v,u)\n\n    dfs1()\n    dfs2()\n    return max(total) - min(subSum)\n```"}
{"task_id": "LeetCode-Hard/22", "completion": "\ndef cycleLengthQueries(n: int, queries: list[list[int]]) -> list[int]:\n    def get_path(n):\n        path = []\n        while(n!=1):\n            path.append(n)\n            n//=2\n        path.append(1)\n        return path[::-1]\n\n    ans = []\n    for a, b in queries:\n        p1, p2 = get_path(a), get_path(b)\n        if p1[-1] != p2[-1]:\n            for _ in p1[::-1]:\n                if _ == p2[-1]:\n                    ans.append(len(p1)+len(p2)-1)\n                    break\n                p1.pop()\n        else:\n            ans.append(len(p1)+len(p2)-1)\n    return ans\n", "raw_completion": "```python\ndef cycleLengthQueries(n: int, queries: list[list[int]]) -> list[int]:\n    def get_path(n):\n        path = []\n        while(n!=1):\n            path.append(n)\n            n//=2\n        path.append(1)\n        return path[::-1]\n\n    ans = []\n    for a, b in queries:\n        p1, p2 = get_path(a), get_path(b)\n        if p1[-1] != p2[-1]:\n            for _ in p1[::-1]:\n                if _ == p2[-1]:\n                    ans.append(len(p1)+len(p2)-1)\n                    break\n                p1.pop()\n        else:\n            ans.append(len(p1)+len(p2)-1)\n    return ans\n```"}
{"task_id": "LeetCode-Hard/30", "completion": "\ndef splitMessage(message: str, limit: int) -> list:\n    if limit <= 5:\n        return []\n    prefix_size = limit - 6\n    parts_count = (len(message) - 1) // prefix_size + 1\n    parts = []\n    for i in range(parts_count):\n        start = i * prefix_size\n        end = start + prefix_size\n        part = message[start:end]\n        if i != parts_count - 1 and len(part) < prefix_size:\n            return []\n        parts.append(part + '<{}/{}>'.format(i+1, parts_count))\n    return parts      \n", "raw_completion": "```python\ndef splitMessage(message: str, limit: int) -> list:\n    if limit <= 5:\n        return []\n    prefix_size = limit - 6\n    parts_count = (len(message) - 1) // prefix_size + 1\n    parts = []\n    for i in range(parts_count):\n        start = i * prefix_size\n        end = start + prefix_size\n        part = message[start:end]\n        if i != parts_count - 1 and len(part) < prefix_size:\n            return []\n        parts.append(part + '<{}/{}>'.format(i+1, parts_count))\n    return parts      \n```"}
{"task_id": "LeetCode-Hard/19", "completion": "\ndef maxPower(stations, r, k):\n    n = len(stations)\n    # calculate initial total power of each city\n    totalPower = [sum(stations[max(0,i-r):min(n,i+r+1)]) for i in range(n)]\n    # build the additional power stations in the least powered cities one by one\n    for _ in range(k):\n        minCity = totalPower.index(min(totalPower))\n        stations[minCity] += 1\n        for i in range(max(0,minCity-r), min(n,minCity+r+1)):\n            totalPower[i] += 1\n    return min(totalPower)\n", "raw_completion": "```python\ndef maxPower(stations, r, k):\n    n = len(stations)\n    # calculate initial total power of each city\n    totalPower = [sum(stations[max(0,i-r):min(n,i+r+1)]) for i in range(n)]\n    # build the additional power stations in the least powered cities one by one\n    for _ in range(k):\n        minCity = totalPower.index(min(totalPower))\n        stations[minCity] += 1\n        for i in range(max(0,minCity-r), min(n,minCity+r+1)):\n            totalPower[i] += 1\n    return min(totalPower)\n```"}
{"task_id": "LeetCode-Hard/25", "completion": "\ndef maxPoints(grid: list[list[int]], queries: list[int]) -> list[int]:\n    m, n = len(grid), len(grid[0])\n    grid_point = sorted([(grid[i][j], i, j) for i in range(m) for j in range(n)], reverse=True)\n    dx, dy = [0, 0, 1, -1], [1, -1, 0, 0]\n    points = [0]*len(queries)\n    for k in range(len(queries)):\n        visited = [[False]*n for _ in range(m)]\n        q = [(0, 0)]\n        visited[0][0] = True\n        while q:\n            x, y = q.pop(0)\n            if grid[x][y] <= queries[k]:\n                points[k] += 1\n                for d in range(4):\n                    nx, ny = x + dx[d], y + dy[d]\n                    if nx >= 0 and ny >= 0 and nx < m and ny < n and not visited[nx][ny] and grid[nx][ny] <= queries[k]:\n                        q.append((nx, ny))\n                        visited[nx][ny] = True\n    return points\n", "raw_completion": "```python\ndef maxPoints(grid: list[list[int]], queries: list[int]) -> list[int]:\n    m, n = len(grid), len(grid[0])\n    grid_point = sorted([(grid[i][j], i, j) for i in range(m) for j in range(n)], reverse=True)\n    dx, dy = [0, 0, 1, -1], [1, -1, 0, 0]\n    points = [0]*len(queries)\n    for k in range(len(queries)):\n        visited = [[False]*n for _ in range(m)]\n        q = [(0, 0)]\n        visited[0][0] = True\n        while q:\n            x, y = q.pop(0)\n            if grid[x][y] <= queries[k]:\n                points[k] += 1\n                for d in range(4):\n                    nx, ny = x + dx[d], y + dy[d]\n                    if nx >= 0 and ny >= 0 and nx < m and ny < n and not visited[nx][ny] and grid[nx][ny] <= queries[k]:\n                        q.append((nx, ny))\n                        visited[nx][ny] = True\n    return points\n```"}
{"task_id": "LeetCode-Hard/31", "completion": "\ndef maxPalindromes(s: str, k: int) -> int:\n    def check(l, r):\n        count = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if r-l+1 >= k:\n                count += 1\n                l -= k\n                r += k-1\n            else:\n                l -= 1\n                r += 1\n        return count\n\n    maxP = 0\n    for i in range(len(s)):\n        maxP = max(maxP, check(i, i))\n        if i < len(s)-1:\n            maxP = max(maxP, check(i, i+1))\n    return maxP\n", "raw_completion": "```python\ndef maxPalindromes(s: str, k: int) -> int:\n    def check(l, r):\n        count = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if r-l+1 >= k:\n                count += 1\n                l -= k\n                r += k-1\n            else:\n                l -= 1\n                r += 1\n        return count\n\n    maxP = 0\n    for i in range(len(s)):\n        maxP = max(maxP, check(i, i))\n        if i < len(s)-1:\n            maxP = max(maxP, check(i, i+1))\n    return maxP\n```"}
{"task_id": "LeetCode-Hard/32", "completion": "\ndef minimumTotalDistance(robot: list[int], factory: list[list[int]]) -> int:\n    robot.sort()\n    factory.sort(key=lambda x: x[0])\n    n, m = len(robot), len(factory)\n    j, total_distance = 0, 0\n    for i in range(n):\n        while factory[j][1] == 0 or (j < m - 1 and abs(robot[i] - factory[j][0]) > abs(robot[i] - factory[j + 1][0])):\n            j += 1\n        total_distance += abs(robot[i] - factory[j][0])\n        factory[j][1] -= 1\n    return total_distance\n", "raw_completion": "```python\ndef minimumTotalDistance(robot: list[int], factory: list[list[int]]) -> int:\n    robot.sort()\n    factory.sort(key=lambda x: x[0])\n    n, m = len(robot), len(factory)\n    j, total_distance = 0, 0\n    for i in range(n):\n        while factory[j][1] == 0 or (j < m - 1 and abs(robot[i] - factory[j][0]) > abs(robot[i] - factory[j + 1][0])):\n            j += 1\n        total_distance += abs(robot[i] - factory[j][0])\n        factory[j][1] -= 1\n    return total_distance\n```"}
{"task_id": "LeetCode-Hard/16", "completion": "\ndef isReachable(targetX: int, targetY: int) -> bool:\n    while targetX >= 1 and targetY >= 1:\n        if targetX > targetY:\n            targetX -= targetY\n        elif targetY > targetX:\n            targetY -= targetX\n        else:\n            return targetX == targetY == 1\n    return False\n", "raw_completion": "```python\ndef isReachable(targetX: int, targetY: int) -> bool:\n    while targetX >= 1 and targetY >= 1:\n        if targetX > targetY:\n            targetX -= targetY\n        elif targetY > targetX:\n            targetY -= targetX\n        else:\n            return targetX == targetY == 1\n    return False\n```"}
{"task_id": "LeetCode-Hard/2", "completion": "\ndef minimumTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[0 for _ in range(n)] for _ in range(m)]\n    heap = [(grid[0][0], 0, 0)]\n    \n    while heap:\n        time, x, y = heapq.heappop(heap)\n        if x == m - 1 and y == n - 1:\n            return time\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and max(time, grid[nx][ny]) > visited[nx][ny]:\n                visited[nx][ny] = max(time, grid[nx][ny])\n                heapq.heappush(heap, (visited[nx][ny], nx, ny))\n    \n    return -1\n", "raw_completion": "```python\ndef minimumTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[0 for _ in range(n)] for _ in range(m)]\n    heap = [(grid[0][0], 0, 0)]\n    \n    while heap:\n        time, x, y = heapq.heappop(heap)\n        if x == m - 1 and y == n - 1:\n            return time\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and max(time, grid[nx][ny]) > visited[nx][ny]:\n                visited[nx][ny] = max(time, grid[nx][ny])\n                heapq.heappush(heap, (visited[nx][ny], nx, ny))\n    \n    return -1\n```"}
{"task_id": "LeetCode-Hard/26", "completion": "\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    G = defaultdict(list)\n    for a, b in edges:\n        G[a].append(b)\n        G[b].append(a)\n    visited, group = [0] * (n + 1), [0] * (n + 1)\n    def dfs(node, g):\n        visited[node] = 1\n        group[node] = g\n        for neighbor in G[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, g + 1):\n                    return False\n            elif abs(group[neighbor] - g) != 1:\n                return False\n        return True\n    for node in range(1, n + 1):\n        if not visited[node] and not dfs(node, 1):\n            return -1\n    return max(group)\n", "raw_completion": "```python\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    G = defaultdict(list)\n    for a, b in edges:\n        G[a].append(b)\n        G[b].append(a)\n    visited, group = [0] * (n + 1), [0] * (n + 1)\n    def dfs(node, g):\n        visited[node] = 1\n        group[node] = g\n        for neighbor in G[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, g + 1):\n                    return False\n            elif abs(group[neighbor] - g) != 1:\n                return False\n        return True\n    for node in range(1, n + 1):\n        if not visited[node] and not dfs(node, 1):\n            return -1\n    return max(group)\n```"}
{"task_id": "LeetCode-Hard/24", "completion": "\ndef minimumTotalCost(nums1: list[int], nums2: list[int]) -> int:\n    n1 = sorted([(v, i) for i, v in enumerate(nums1)])\n    n2 = sorted([(v, i) for i, v in enumerate(nums2)])\n\n    i = j = res = 0\n    while i < len(n1) and j < len(n2):\n        if n1[i][0] < n2[j][0] or (i > 0 and n1[i][0] == n1[i - 1][0]):\n            res += n1[i][1]\n            i += 1\n        elif n2[j][0] < n1[i][0] or (j > 0 and n2[j][0] == n2[j - 1][0]):\n            res += n2[j][1] if n2[j][1] not in [n1[k][1] for k in range(i)] else 0\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    for k in range(i, len(n1)):\n        res += n1[k][1]\n\n    return -1 if sum(nums1) != sum(nums2) else res\n", "raw_completion": "```python\ndef minimumTotalCost(nums1: list[int], nums2: list[int]) -> int:\n    n1 = sorted([(v, i) for i, v in enumerate(nums1)])\n    n2 = sorted([(v, i) for i, v in enumerate(nums2)])\n\n    i = j = res = 0\n    while i < len(n1) and j < len(n2):\n        if n1[i][0] < n2[j][0] or (i > 0 and n1[i][0] == n1[i - 1][0]):\n            res += n1[i][1]\n            i += 1\n        elif n2[j][0] < n1[i][0] or (j > 0 and n2[j][0] == n2[j - 1][0]):\n            res += n2[j][1] if n2[j][1] not in [n1[k][1] for k in range(i)] else 0\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    for k in range(i, len(n1)):\n        res += n1[k][1]\n\n    return -1 if sum(nums1) != sum(nums2) else res\n```"}
{"task_id": "LeetCode-Hard/5", "completion": "\ndef minimumScore(s: str, t: str) -> int:\n    match_indexes = []\n    for char in t:\n        if char in s:\n            match_index = s.index(char)\n            s = s[match_index+1:]\n            match_indexes.append(match_index)\n    if not match_indexes:\n        return len(t)\n    return match_indexes[-1] - match_indexes[0] + 1  \n", "raw_completion": "```python\ndef minimumScore(s: str, t: str) -> int:\n    match_indexes = []\n    for char in t:\n        if char in s:\n            match_index = s.index(char)\n            s = s[match_index+1:]\n            match_indexes.append(match_index)\n    if not match_indexes:\n        return len(t)\n    return match_indexes[-1] - match_indexes[0] + 1  \n```"}